[TOC]

# Django 官方文档学习笔记

> 文档地址：https://docs.djangoproject.com/zh-hans/3.2/contents/
>
> 环境：`macOS10.13.1 + python3.7.3 + Django3.2`

## 安装 `Django` 环境

| Django 版本 | Python 版本                                          |
| ----------- | ---------------------------------------------------- |
| 2.2         | 3.5，3.6，3.7，3.8（2.2.8 添加），3.9（2.2.17 添加） |
| 3.0         | 3.6，3.7，3.8，3.9 （3.0.11 添加）                   |
| 3.1         | 3.6，3.7，3.8，3.9（3.1.3 添加）                     |
| 3.2         | 3.6, 3.7, 3.8, 3.9                                   |

- 安装 `Apache` 和 `mod_wsgi`

如果要在生产站点上使用 `Django`，请将 [Apache](https://httpd.apache.org/) 与 [mod_wsgi](https://modwsgi.readthedocs.io/en/develop/) 一起使用。 `mod_wsgi` 能以两种模式运行：

> **嵌入模式**：在该模式下，`mod_wsgi` 类似于 `mod_perl` —— 它在 `Apache` 中嵌入 `Python`，并在服务器启动时将 `Python` 代码加载到内存中。代码在 `Apache` 进程的整个生命周期中都保留在内存中，与其他服务器相比，这可以显着提高性能；
>
> **守护进程模式**：在该模式下，`mod_wsgi` 会生成一个处理请求的独立守护进程。守护进程可以作为与 `Web` 服务器不同的用户运行，可能会提高安全性。可以在不重新启动整个 `Apache Web` 服务器的情况下重新启动守护进程，从而可以更加无缝地刷新代码库。

`Django` 另一种部署方式：`uWSGI` + `nginx`。

> [uWSGI](https://uwsgi-docs.readthedocs.io/) 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完全由 `C` 编写。
>
> `uWSGI` 以客户端-服务端模型运行。`Web` 服务器（例如 `nginx`，`Apache`）与一个 `django-uwsgi` “`worker`" 进程交互，提供动态内容。

```bash
# 安装
(django3.2) (base) ☁  ~  python -m pip install uwsgi
# or
(django3.2) (base) ☁  ~  python -m pip install https://projects.unbit.it/downloads/uwsgi-lts.tar.gz

# mac建议用conda安装
(base) ☁  pro_django [master] conda install -c conda-forge uwsgi
```

- 配置并启动用于 `Django` 的 `uWSGI` 服务器

`uWSGI` 以客户端-服务端模型运行。`Web` 服务器（例如 `nginx`，`Apache`）与一个 `django-uwsgi` “`worker`" 进程交互，提供动态内容。

1）命令启动

```bash
(base) ☁  pro_django [master] ⚡ sudo uwsgi --chdir=/home/projects/python_pro/pro_django/mysite \
                                      --module=mysite.wsgi:application \
                                      --master --pidfile=/Users/zhangbocheng/project-mysite-master.pid \
                                      --socket=127.0.0.1:49152 \
                                      --processes=5 \
                                      --uid=1000 --gid=2000 \
                                      --harakiri=20 \
                                      --max-requests=5000 \
                                      --vacuum \
                                      --home=/Users/zhangbocheng/.virtualenvs/django3.2 \
                                      --daemonize=/Users/zhangbocheng/project-mysite-master.log
```

2）配置文件启动

```bash
 # 创建ini配置文件
 (base) ☁  pro_django [master] ⚡  vi uwsig.ini
 [uwsgi]
 chdir=/home/projects/python_pro/pro_django/mysite
 module=mysite.wsgi:application
 master=True
 pidfile=/Users/zhangbocheng/project-mysite-master.pid
 socket=127.0.0.1:49152
 processes=5
 uid=1000
 gid=2000
 harakiri=20
 max-requests=5000
 vacuum=True
 home=/Users/zhangbocheng/.virtualenvs/django3.2
 daemonize=/Users/zhangbocheng/project-mysite-master.log
 :wq
  
 # 启动
 (base) ☁  pro_django [master] ⚡ sudo uwsgi --ini uwsig.ini
```

- 安装 `Django`

```bash
(base) ☁  pro_django [master] ⚡  pip install django==3.2
```

## 数据库

`Django` 官方支持以下数据库：（假设所有的数据库都使用 `UTF-8` 编码）

> `PostgreSQL`：支持 `PostgreSQL 9.6` 及以上版本；
>
> `MariaDB`：支持 `MariaDB 10.2` 及以上版本；
>
> `MySQL`：
>
> > 支持 `MySQL 5.7` 及以上版本；
> >
> > `inspectdb` 功能使用 `information_schema` 数据库；
> >
> > `Django` 需要 `mysqlclient 1.4.0` 或更高版本；
> >
> > 如果使用 `Django` 的时区支持，使用 `mysql_tzinfo_to_sql` 将时区表加载到 `MySQL` 数据库中；
> >
> > 默认情况下，对于 `UTF-8` 数据库，`MySQL` 将使用 `utf8_general_ci` 字符序。这将导致所有字符串的平等比较以一种不区分大小写的方式进行；如果想在某一列或表上进行区分大小写的比较，请将该列或表改为使用 `utf8_bin` 字符序；
> >
> > 根据 `MySQL Unicode` 字符集 ，`utf8_general_ci` 的比较比 `utf8_unicode_ci` 的比较要快，但正确率略低。
> >
> > 连接数据库：
> >
> > ```python
> > # settings.py
> > DATABASES = {
> >     'default': {
> >         'ENGINE': 'django.db.backends.mysql',
> >         'OPTIONS': {
> >             'read_default_file': '/path/to/my.cnf',
> >         },
> >     }
> > }
> > 
> > 
> > # my.cnf
> > [client]
> > database = NAME
> > user = USER
> > password = PASSWORD
> > default-character-set = utf8
> > ```
>
> `Oracle`
>
> ```python
> DATABASES = {
>     'default': {
>         'ENGINE': 'django.db.backends.oracle',
>         'NAME': 'xe',
>         'USER': 'a_user',
>         'PASSWORD': 'a_password',
>         'HOST': '',
>         'PORT': '',
>     }
> }
> ```
>
> `SQLite`

**持久连接** 避免了在每次请求中重新建立与数据库连接的开销。它们由 `CONN_MAX_AGE` 参数控制，该参数定义了一个连接的最大寿命，可以为每个数据库独立设置，默认值是 0，保留了每次请求结束时关闭数据库连接的历史行为。要启用持久连接，可将 `CONN_MAX_AGE` 设置为正整数秒；对于无限制的持久连接，将其设置为 `None`；

**连接管理**：当 `Django` 第一次进行数据库查询时，就会打开一个与数据库的连接；它保持这个连接的开放性，并在以后的请求中重复使用。一旦连接超过了 `CONN_MAX_AGE` 所定义的最大时长，或者当它不再可用时，`Django` 就会关闭这个连接。

## 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。

```bash
In [1]: from django_db.models import *

In [2]: p = Person(first_name='Fred', last_name='Flintstone', shirt_size='L')

In [3]: p.save()

In [4]: p.shirt_size
Out[4]: 'L'

In [5]: p.get_shirt_size_display()
Out[5]: 'Large'
```

```bash
# 多对多关系查询
In [21]: beatle.members.all()
Out[21]: <QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>

# 添加多对多关系
In [23]: join = Person.objects.create(name="John", shirt_size='L')

In [24]: beatle.members.add(join, through_defaults={'date_joined': date(1963,8,1)})

In [25]: beatle.members.create(name='George Harrison', shirt_size='M', through_defaults={'date_joined': date(1963,8,1)})
Out[25]: <Person: George Harrison>

In [27]: beatle.members.set([join, paul, ringo], through_defaults={'date_joined': date(1963,8,1)})
```

`Django` 对模型的字段名有一些限制：

> 1）一个字段的名称不能是 `Python` 保留字，因为这会导致 `Python` 语法错误；
>
> 2）一个字段名称不能包含连续的多个下划线，原因在于 Django 查询语法的工作方式；
>
> 3）字段名不能以下划线结尾。

- `Meta` 选项

> `abstract`：如果 `abstract = True`，这个模型将是一个抽象基类；
>
> `app_label`：如果在 `INSTALLED_APPS` 中定义了一个应用程序之外的模型，它必须声明它属于哪个应用程序；
>
> `base_manager_name`：管理器的属性名，例如，`'objects'`，用于模型的 `_base_manager`；
>
> `db_table`：用于模型的数据库表的名称；
>
> `db_tablespace`：此模型要使用的数据库表空间名称；
>
> `default_manager_name`：模型的 `_default_manager` 管理器名称；
>
> `default_related_name`：从相关对象到这个对象的关系默认使用的名称，默认为 `_set`；这个选项还可以设置 `related_query_name`；
>
> `get_latest_by`：模型中的字段名或字段名列表，通常是 `DateField`，`DateTimeField` 或 `IntegerField`。这指定了在你的模型中使用的默认字段 `Manager` 的 `last()` 和 `earliest()` 方法；
>
> `managed`：默认为 `True`，意味着 `Django` 会在 `migrate` 中创建相应的数据库表，或者作为迁移的一部分，并作为 `flush` 管理命令的一部分删除它们。也就是说，`Django` 管理数据库表的生命周期；如果 `False`，将不对该模型进行数据库表的创建、修改或删除操作；
>
> `order_with_respect_to`：使该对象可以根据给定字段（通常是 `ForeignKey` ）进行排序，这可以用来使相关对象相对于父对象可排序；
>
> ```bash
> In [8]: q = Question.objects.get(id=1)
> 
> In [9]: q.get_answer_order()
> Out[9]: <QuerySet [1, 2, 3]>
> 
> In [10]: q.set_answer_order([3,1,2])
> 
> In [11]: q.get_answer_order()
> Out[11]: <QuerySet [3, 1, 2]>
> ```
>
> `ordering`：对象的默认排序，用于获取对象列表，每一个字符串都是一个字段名，前面有一个可选的“-”字头，表示降序；没有前缀“-”的字段将按升序排列；使用字符串“?”来随机排序；
>
> `permissions`：创建此对象时要输入权限表的额外权限，为每个模型自动创建添加、更改、删除和查看权限，格式为 `(permission_code, human_readable_permission_name)`；
>
> `default_permissions`：默认值为 `('add', 'change', 'delete', 'view')` ；
>
> `proxy`：如果 `proxy = True`，作为另一个模型子类的模型将被视为代理模型；
>
> `required_db_features：当前连接应具备的数据库特征列表，以便在迁移阶段考虑模型；
>
> `required_db_vendor`：本模型所特有的支持的数据库厂商名称，目前的内置厂商名称是： sqlite`，postgresql`，mysql` 和 oracle`，如果该属性不为空，且当前连接厂商与之不匹配，则该模型将不会同步；
>
> `select_on_save`：确定 `Django` 是否会使用 1.6 之前的 `django.db.models.Model.save()`算法。旧的算法使用 `SELECT` 来确定是否有一条现有的记录需要更新。新算法直接尝试 `UPDATE`；通常不需要设置这个属性。默认值是 `False`；
>
> `indexes`：在模型上定义的 `indexes` 的列表；
>
> `unique_together`：一组字段名，合起来必须是唯一的；
>
> > 使用 `UniqueConstraint` 与 `constraint` 选项代替；
> >
> > `UniqueConstraint` 比 `unique_together` 提供更多的功能，`unique_together` 今后可能会被废弃。
>
> `index_together`：一组字段名，合在一起，是有索引的；
>
> > 使用 `indexes` 选项代替；
> >
> > 新的 `indexes` 选项比 `index_together` 提供了更多的功能，`index_together` 今后可能会被废弃。
>
> `constraints`：在模型上定义的约束列表；
>
> `verbose_name`：对象的可读名称，单数；
>
> `verbose_name_plural`：对象的复数名称；
>
> `label`：对象的表示，返回 `app_label.object_name`，例如 `'polls.Question'`；
>
> `label_lower`：模型的表示，返回 `app_label.model_name`，例如 `'polls.question'`。

- 模型方法

在模型中添加自定义方法会给你的对象提供自定义的“行级”操作能力。与之对应的是类 `Manager` 的方法意在提供“表级”的操作，模型方法应该在某个对象实例上生效。

- 模型继承

1）**抽象基类** 在你要将公共信息放入很多模型时会很有用。编写你的基类，并在 `Meta` 类中填入 `abstract=True`。该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。

**`Meta` 继承**：当一个抽象基类被建立，`Django` 将所有在基类中申明的 `Meta` 内部类以属性的形式提供。若子类未定义自己的 `Meta` 类，它会继承父类的 `Meta` ，当然，子类也可继承父类的 `Meta` 。

> 如果子类从多个抽象基类继承，则默认情况下仅继承第一个列出的类的`Meta` 选项，为了从多个抽象类中继承 `Meta` 选项，必须显式地声明`Meta` 继承。

若在 `外键` 或 `多对多字段` 使用了 `related_name` 或 `related_query_name`，你必须为该字段提供一个独一无二的反向名字和查询名字。这在抽象基类中一般会引发问题，因为基类中的字段都被子类继承，且保持了同样的值（包括  `related_name` 或 `related_query_name`），为了解决此问题，当在抽象基类中（也只能是在抽象基类中）使用  `related_name` 或 `related_query_name`，部分值需要包含 `'%(app_label)s'` 和 `'%(class)s'`。

> `'%(class)s'` 用使用了该字段的子类的小写类名替换；
>
> `'%(app_label)s'` 用小写的包含子类的应用名替换。每个安装的应用名必须是唯一的，应用内的每个模型类名也必须是唯一的。因此，替换后的名字也是唯一的。

2）**多表继承**：`Django` 支持的第二种模型继承方式是层次结构中的每个模型都是一个单独的模型。每个模型都指向分离的数据表，且可被独立查询和创建。

> 多表继承情况下，子类不会继承父类的 `Meta`。

3）**代理模型**：为原模型创建一个代理，可以创建，删除和更新代理模型的实例，所有的数据都会存储像使用原模型（未代理的）一样；不同点是可以修改代理默认的模型排序和默认管理器，而不需要修改原模型。

> 一个代理模型必须继承自一个非抽象模型类，不能继承多个非抽象模型类，因为代理模型无法在不同数据表之间提供任何行间连接；
>
> 一个代理模型可以继承任意数量的抽象模型类，假如他们没有定义任何的模型字段；
>
> 一个代理模型也可以继承任意数量的代理模型，只需他们共享同一个非抽象父类。

多重继承：如果存在多个父类包含 `Meta`，只有第一个会被使用，其它的都会被忽略；继承自多个包含 `id` 主键的字段会抛出错误；正确的使用多继承，你可以在基类中显示使用 `AutoField`。

在一个包中管理模型：

```bash
# myapp/models/__init__.py
from .organic import Person
from .synthetic import Robot
```

## 执行查询

## 聚合

## 搜索

## 管理器

## 执行原生 `SQL` 查询

## 数据库事务

## 多数据库

## 表空间

## 数据库访问优化

## 数据库工具

## 模型关联 `API` 示例





## 项目问题及解决方案

1，`uwsgi` 运行报错，具体信息如下：

```bash
(django3.2) (base) ☁  mysite [master] ⚡  uwsgi --help
dyld: Library not loaded: @rpath/libpcre.1.dylib
  Referenced from: /Users/zhangbocheng/.virtualenvs/django3.2/bin/uwsgi
  Reason: image not found
[1]    75254 abort      uwsgi --help
```

解决方案：用 `conda` 安装。





## 参考资料

- [Pip 安装uwsgi报错，用conda吧](https://blog.csdn.net/BIKEONEPIECE/article/details/105882799)

