[TOC]

# Django 官方文档学习笔记

> 文档地址：https://docs.djangoproject.com/zh-hans/3.2/contents/
>
> 环境：`macOS10.13.1 + python3.7.3 + Django3.2`

## 安装 `Django` 环境

| Django 版本 | Python 版本                                          |
| ----------- | ---------------------------------------------------- |
| 2.2         | 3.5，3.6，3.7，3.8（2.2.8 添加），3.9（2.2.17 添加） |
| 3.0         | 3.6，3.7，3.8，3.9 （3.0.11 添加）                   |
| 3.1         | 3.6，3.7，3.8，3.9（3.1.3 添加）                     |
| 3.2         | 3.6, 3.7, 3.8, 3.9                                   |

- 安装 `Apache` 和 `mod_wsgi`

如果要在生产站点上使用 `Django`，请将 [Apache](https://httpd.apache.org/) 与 [mod_wsgi](https://modwsgi.readthedocs.io/en/develop/) 一起使用。 `mod_wsgi` 能以两种模式运行：

> **嵌入模式**：在该模式下，`mod_wsgi` 类似于 `mod_perl` —— 它在 `Apache` 中嵌入 `Python`，并在服务器启动时将 `Python` 代码加载到内存中。代码在 `Apache` 进程的整个生命周期中都保留在内存中，与其他服务器相比，这可以显着提高性能；
>
> **守护进程模式**：在该模式下，`mod_wsgi` 会生成一个处理请求的独立守护进程。守护进程可以作为与 `Web` 服务器不同的用户运行，可能会提高安全性。可以在不重新启动整个 `Apache Web` 服务器的情况下重新启动守护进程，从而可以更加无缝地刷新代码库。

`Django` 另一种部署方式：`uWSGI` + `nginx`。

> [uWSGI](https://uwsgi-docs.readthedocs.io/) 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完全由 `C` 编写。
>
> `uWSGI` 以客户端-服务端模型运行。`Web` 服务器（例如 `nginx`，`Apache`）与一个 `django-uwsgi` “`worker`" 进程交互，提供动态内容。

```bash
# 安装
(django3.2) (base) ☁  ~  python -m pip install uwsgi
# or
(django3.2) (base) ☁  ~  python -m pip install https://projects.unbit.it/downloads/uwsgi-lts.tar.gz

# mac建议用conda安装
(base) ☁  pro_django [master] conda install -c conda-forge uwsgi
```

- 配置并启动用于 `Django` 的 `uWSGI` 服务器

`uWSGI` 以客户端-服务端模型运行。`Web` 服务器（例如 `nginx`，`Apache`）与一个 `django-uwsgi` “`worker`" 进程交互，提供动态内容。

1）命令启动

```bash
(base) ☁  pro_django [master] ⚡ sudo uwsgi --chdir=/home/projects/python_pro/pro_django/mysite \
                                      --module=mysite.wsgi:application \
                                      --master --pidfile=/Users/zhangbocheng/project-mysite-master.pid \
                                      --socket=127.0.0.1:49152 \
                                      --processes=5 \
                                      --uid=1000 --gid=2000 \
                                      --harakiri=20 \
                                      --max-requests=5000 \
                                      --vacuum \
                                      --home=/Users/zhangbocheng/.virtualenvs/django3.2 \
                                      --daemonize=/Users/zhangbocheng/project-mysite-master.log
```

2）配置文件启动

```bash
 # 创建ini配置文件
 (base) ☁  pro_django [master] ⚡  vi uwsig.ini
 [uwsgi]
 chdir=/home/projects/python_pro/pro_django/mysite
 module=mysite.wsgi:application
 master=True
 pidfile=/Users/zhangbocheng/project-mysite-master.pid
 socket=127.0.0.1:49152
 processes=5
 uid=1000
 gid=2000
 harakiri=20
 max-requests=5000
 vacuum=True
 home=/Users/zhangbocheng/.virtualenvs/django3.2
 daemonize=/Users/zhangbocheng/project-mysite-master.log
 :wq
  
 # 启动
 (base) ☁  pro_django [master] ⚡ sudo uwsgi --ini uwsig.ini
```

- 安装 `Django`

```bash
(base) ☁  pro_django [master] ⚡  pip install django==3.2
```

## 数据库

`Django` 官方支持以下数据库：（假设所有的数据库都使用 `UTF-8` 编码）

> `PostgreSQL`：支持 `PostgreSQL 9.6` 及以上版本；
>
> `MariaDB`：支持 `MariaDB 10.2` 及以上版本；
>
> `MySQL`：
>
> > 支持 `MySQL 5.7` 及以上版本；
> >
> > `inspectdb` 功能使用 `information_schema` 数据库；
> >
> > `Django` 需要 `mysqlclient 1.4.0` 或更高版本；
> >
> > 如果使用 `Django` 的时区支持，使用 `mysql_tzinfo_to_sql` 将时区表加载到 `MySQL` 数据库中；
> >
> > 默认情况下，对于 `UTF-8` 数据库，`MySQL` 将使用 `utf8_general_ci` 字符序。这将导致所有字符串的平等比较以一种不区分大小写的方式进行；如果想在某一列或表上进行区分大小写的比较，请将该列或表改为使用 `utf8_bin` 字符序；
> >
> > 根据 `MySQL Unicode` 字符集 ，`utf8_general_ci` 的比较比 `utf8_unicode_ci` 的比较要快，但正确率略低。
> >
> > 连接数据库：
> >
> > ```python
> > # settings.py
> > DATABASES = {
> >     'default': {
> >         'ENGINE': 'django.db.backends.mysql',
> >         'OPTIONS': {
> >             'read_default_file': '/path/to/my.cnf',
> >         },
> >     }
> > }
> > 
> > 
> > # my.cnf
> > [client]
> > database = NAME
> > user = USER
> > password = PASSWORD
> > default-character-set = utf8
> > ```
>
> `Oracle`
>
> ```python
> DATABASES = {
>     'default': {
>         'ENGINE': 'django.db.backends.oracle',
>         'NAME': 'xe',
>         'USER': 'a_user',
>         'PASSWORD': 'a_password',
>         'HOST': '',
>         'PORT': '',
>     }
> }
> ```
>
> `SQLite`

**持久连接** 避免了在每次请求中重新建立与数据库连接的开销。它们由 `CONN_MAX_AGE` 参数控制，该参数定义了一个连接的最大寿命，可以为每个数据库独立设置，默认值是 0，保留了每次请求结束时关闭数据库连接的历史行为。要启用持久连接，可将 `CONN_MAX_AGE` 设置为正整数秒；对于无限制的持久连接，将其设置为 `None`；

**连接管理**：当 `Django` 第一次进行数据库查询时，就会打开一个与数据库的连接；它保持这个连接的开放性，并在以后的请求中重复使用。一旦连接超过了 `CONN_MAX_AGE` 所定义的最大时长，或者当它不再可用时，`Django` 就会关闭这个连接。

## 模型

模型准确且唯一的描述了数据。它包含您储存的数据的重要字段和行为。一般来说，每一个模型都映射一张数据库表。

对于一个模型实例，要获取该字段二元组中相对应的第二个值，使用 [`get_FOO_display()`](https://docs.djangoproject.com/zh-hans/3.2/ref/models/instances/#django.db.models.Model.get_FOO_display) 方法。

```bash
In [1]: from django_db.models import *

In [2]: p = Person(first_name='Fred', last_name='Flintstone', shirt_size='L')

In [3]: p.save()

In [4]: p.shirt_size
Out[4]: 'L'

In [5]: p.get_shirt_size_display()
Out[5]: 'Large'
```

```bash
# 多对多关系查询
In [21]: beatle.members.all()
Out[21]: <QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>

# 添加多对多关系
In [23]: join = Person.objects.create(name="John", shirt_size='L')

In [24]: beatle.members.add(join, through_defaults={'date_joined': date(1963,8,1)})

In [25]: beatle.members.create(name='George Harrison', shirt_size='M', through_defaults={'date_joined': date(1963,8,1)})
Out[25]: <Person: George Harrison>

In [27]: beatle.members.set([join, paul, ringo], through_defaults={'date_joined': date(1963,8,1)})
```

`Django` 对模型的字段名有一些限制：

> 1）一个字段的名称不能是 `Python` 保留字，因为这会导致 `Python` 语法错误；
>
> 2）一个字段名称不能包含连续的多个下划线，原因在于 Django 查询语法的工作方式；
>
> 3）字段名不能以下划线结尾。

- `Meta` 选项

> `abstract`：如果 `abstract = True`，这个模型将是一个抽象基类；
>
> `app_label`：如果在 `INSTALLED_APPS` 中定义了一个应用程序之外的模型，它必须声明它属于哪个应用程序；
>
> `base_manager_name`：管理器的属性名，例如，`'objects'`，用于模型的 `_base_manager`；
>
> `db_table`：用于模型的数据库表的名称；
>
> `db_tablespace`：此模型要使用的数据库表空间名称；
>
> `default_manager_name`：模型的 `_default_manager` 管理器名称；
>
> `default_related_name`：从相关对象到这个对象的关系默认使用的名称，默认为 `_set`；这个选项还可以设置 `related_query_name`；
>
> `get_latest_by`：模型中的字段名或字段名列表，通常是 `DateField`，`DateTimeField` 或 `IntegerField`。这指定了在你的模型中使用的默认字段 `Manager` 的 `last()` 和 `earliest()` 方法；
>
> `managed`：默认为 `True`，意味着 `Django` 会在 `migrate` 中创建相应的数据库表，或者作为迁移的一部分，并作为 `flush` 管理命令的一部分删除它们。也就是说，`Django` 管理数据库表的生命周期；如果 `False`，将不对该模型进行数据库表的创建、修改或删除操作；
>
> `order_with_respect_to`：使该对象可以根据给定字段（通常是 `ForeignKey` ）进行排序，这可以用来使相关对象相对于父对象可排序；
>
> ```bash
> In [8]: q = Question.objects.get(id=1)
> 
> In [9]: q.get_answer_order()
> Out[9]: <QuerySet [1, 2, 3]>
> 
> In [10]: q.set_answer_order([3,1,2])
> 
> In [11]: q.get_answer_order()
> Out[11]: <QuerySet [3, 1, 2]>
> ```
>
> `ordering`：对象的默认排序，用于获取对象列表，每一个字符串都是一个字段名，前面有一个可选的“-”字头，表示降序；没有前缀“-”的字段将按升序排列；使用字符串“?”来随机排序；
>
> `permissions`：创建此对象时要输入权限表的额外权限，为每个模型自动创建添加、更改、删除和查看权限，格式为 `(permission_code, human_readable_permission_name)`；
>
> `default_permissions`：默认值为 `('add', 'change', 'delete', 'view')` ；
>
> `proxy`：如果 `proxy = True`，作为另一个模型子类的模型将被视为代理模型；
>
> `required_db_features：当前连接应具备的数据库特征列表，以便在迁移阶段考虑模型；
>
> `required_db_vendor`：本模型所特有的支持的数据库厂商名称，目前的内置厂商名称是： sqlite`，postgresql`，mysql` 和 oracle`，如果该属性不为空，且当前连接厂商与之不匹配，则该模型将不会同步；
>
> `select_on_save`：确定 `Django` 是否会使用 1.6 之前的 `django.db.models.Model.save()`算法。旧的算法使用 `SELECT` 来确定是否有一条现有的记录需要更新。新算法直接尝试 `UPDATE`；通常不需要设置这个属性。默认值是 `False`；
>
> `indexes`：在模型上定义的 `indexes` 的列表；
>
> `unique_together`：一组字段名，合起来必须是唯一的；
>
> > 使用 `UniqueConstraint` 与 `constraint` 选项代替；
> >
> > `UniqueConstraint` 比 `unique_together` 提供更多的功能，`unique_together` 今后可能会被废弃。
>
> `index_together`：一组字段名，合在一起，是有索引的；
>
> > 使用 `indexes` 选项代替；
> >
> > 新的 `indexes` 选项比 `index_together` 提供了更多的功能，`index_together` 今后可能会被废弃。
>
> `constraints`：在模型上定义的约束列表；
>
> `verbose_name`：对象的可读名称，单数；
>
> `verbose_name_plural`：对象的复数名称；
>
> `label`：对象的表示，返回 `app_label.object_name`，例如 `'polls.Question'`；
>
> `label_lower`：模型的表示，返回 `app_label.model_name`，例如 `'polls.question'`。

- 模型方法

在模型中添加自定义方法会给你的对象提供自定义的“行级”操作能力。与之对应的是类 `Manager` 的方法意在提供“表级”的操作，模型方法应该在某个对象实例上生效。

- 模型继承

1）**抽象基类** 在你要将公共信息放入很多模型时会很有用。编写你的基类，并在 `Meta` 类中填入 `abstract=True`。该模型将不会创建任何数据表。当其用作其它模型类的基类时，它的字段会自动添加至子类。

**`Meta` 继承**：当一个抽象基类被建立，`Django` 将所有在基类中申明的 `Meta` 内部类以属性的形式提供。若子类未定义自己的 `Meta` 类，它会继承父类的 `Meta` ，当然，子类也可继承父类的 `Meta` 。

> 如果子类从多个抽象基类继承，则默认情况下仅继承第一个列出的类的`Meta` 选项，为了从多个抽象类中继承 `Meta` 选项，必须显式地声明`Meta` 继承。

若在 `外键` 或 `多对多字段` 使用了 `related_name` 或 `related_query_name`，你必须为该字段提供一个独一无二的反向名字和查询名字。这在抽象基类中一般会引发问题，因为基类中的字段都被子类继承，且保持了同样的值（包括  `related_name` 或 `related_query_name`），为了解决此问题，当在抽象基类中（也只能是在抽象基类中）使用  `related_name` 或 `related_query_name`，部分值需要包含 `'%(app_label)s'` 和 `'%(class)s'`。

> `'%(class)s'` 用使用了该字段的子类的小写类名替换；
>
> `'%(app_label)s'` 用小写的包含子类的应用名替换。每个安装的应用名必须是唯一的，应用内的每个模型类名也必须是唯一的。因此，替换后的名字也是唯一的。

2）**多表继承**：`Django` 支持的第二种模型继承方式是层次结构中的每个模型都是一个单独的模型。每个模型都指向分离的数据表，且可被独立查询和创建。

> 多表继承情况下，子类不会继承父类的 `Meta`。

3）**代理模型**：为原模型创建一个代理，可以创建，删除和更新代理模型的实例，所有的数据都会存储像使用原模型（未代理的）一样；不同点是可以修改代理默认的模型排序和默认管理器，而不需要修改原模型。

> 一个代理模型必须继承自一个非抽象模型类，不能继承多个非抽象模型类，因为代理模型无法在不同数据表之间提供任何行间连接；
>
> 一个代理模型可以继承任意数量的抽象模型类，假如他们没有定义任何的模型字段；
>
> 一个代理模型也可以继承任意数量的代理模型，只需他们共享同一个非抽象父类。

多重继承：如果存在多个父类包含 `Meta`，只有第一个会被使用，其它的都会被忽略；继承自多个包含 `id` 主键的字段会抛出错误；正确的使用多继承，你可以在基类中显示使用 `AutoField`。

在一个包中管理模型：

```bash
# myapp/models/__init__.py
from .organic import Person
from .synthetic import Robot
```

## 执行查询

创建对象：

```bash
In [3]: b = Blog(name='Beatles Blog', tag_line="All the lastest Beatles news.")

In [4]: b.save()

In [5]: Blog.objects.create(name='BBC Blog', tag_line="All the lastest BBC news.")
Out[5]: <Blog: BBC Blog>

# 修改
In [11]: b.name = "English's BBC"

In [12]: b.save()

In [36]: entry = Entry(blog=b, head_line="News of BBS", body_text="test")

In [58]: cheese_blog = Blog.objects.get(name="Cheddar Talk")

In [59]: entry.blog = cheese_blog

In [61]: entry.save()

In [62]: Joe = Author.objects.create(name="Joe")

In [64]: entry.authors.add(Joe)

In [65]: John = Author.objects.create(name="John")

In [66]: paul = Author.objects.create(name="Paul")

In [67]: entry.authors.add(John, paul)

```

一个 `QuerySet` 代表来自数据库中对象的一个集合。它可以有 0 个，1 个或者多个 `filters`； `Filters`，可以根据给定参数缩小查询结果量。在 `SQL` 的层面上， `QuerySet` 对应 `SELECT` 语句，而 `filters` 对应类似 `WHERE` 或 `LIMIT` 的限制子句。

检索全部对象：方法 `all()` 返回了一个包含数据库中所有对象的 `QuerySet` 对象。

通过过滤器检索指定对象：最常见的精炼 `QuerySet` 的方式：

> `filter(**kwargs)`：返回一个新的 `QuerySet`，包含的对象满足给定查询参数；
>
> `exclude(**kwargs)`：返回一个新的 `QuerySet`，包含的对象不满足给定查询参数。

每次精炼一个 `QuerySet`，你就会获得一个全新的 `QuerySet`，后者与前者毫无关联。每次精炼都会创建一个单独的、不同的 `QuerySet`，能被存储，使用和复用。

`QuerySet` 是**惰性的** —— 创建 `QuerySet` 并不会引发任何数据库活动。你可以将一整天的过滤器都堆积在一起，`Django` 只会在  `QuerySet` 被计算时执行查询操作。

使用切片 `[0]` 时的 `get()` 和 `filter()` 有点不同：如果没有满足查询条件的结果， `get()` 会抛出一个 `DoesNotExist` 异常；`Django` 会在有不止一个记录满足 `get()` 查询条件时发出警告，这时，`Django` 会抛出 `MultipleObjectsReturned`。

`F()` 的实例充当查询中的模型字段的引用。这些引用可在查询过滤器中用于在同一模型实例中比较两个不同的字段。

等效于 `LIKE` `SQL` 语句的字段查询子句 (`iexact`， `contains`， `icontains`， `startswith`， `istartswith`， `endswith` 和 `iendswith`) 会将 `LIKE` 语句中有特殊用途的两个符号，即百分号和下划线自动转义。

每个 `QuerySet` 都带有缓存，尽量减少数据库访问：

> 1）新创建的 `QuerySet` 缓存是空的；
>
> 2）一旦要计算 `QuerySet` 的值，就会执行数据查询；
>
> 3）`Django` 就会将查询结果保存在 `QuerySet` 的缓存中，并返回这些显式请求的缓存：
>
> 4）后续针对 `QuerySet` 的计算会复用缓存结果。

当查询时，`None` 值将一直被解释为 `JSON` 的 `null`，要查询 `SQL` 的 `NULL`，请使用 `isnull`。

利用 `Python` 的数组切片语法将 `QuerySet` 切成指定长度，但是不支持负索引 (例如 `Entry.objects.all()[-1]`)。

```bash
# F查询
In [8]: qs = Entry.objects.filter(number_of_comments__gt=F('number_of_pingbacks'))

In [9]: print(qs.query)
SELECT `web_entry`.`id`, `web_entry`.`blog_id`, `web_entry`.`head_line`, `web_entry`.`body_text`, `web_entry`.`pub_date`, `web_entry`.`mod_date`, `web_entry`.`number_of_comments`, `web_entry`.`number_of_pingbacks`, `web_entry`.`rating` FROM `web_entry` WHERE `web_entry`.`number_of_comments` > `web_entry`.`number_of_pingbacks`

# 注意下两个语句的区别
In [2]: qs1 = Blog.objects.filter(entry__head_line__contains="Lennon", entry__pub_date__year=2008)

In [3]: print(qs1.query)
SELECT `web_blog`.`id`, `web_blog`.`name`, `web_blog`.`tag_line` FROM `web_blog` INNER JOIN `web_entry` ON (`web_blog`.`id` = `web_entry`.`blog_id`) WHERE (`web_entry`.`head_line` LIKE BINARY %Lennon% AND `web_entry`.`pub_date` BETWEEN 2008-01-01 AND 2008-12-31)

In [4]: qs2 = Blog.objects.filter(entry__head_line__contains="Lennon").filter(entry__pub_date__year=2008)

In [5]: print(qs2.query)
SELECT `web_blog`.`id`, `web_blog`.`name`, `web_blog`.`tag_line` FROM `web_blog` INNER JOIN `web_entry` ON (`web_blog`.`id` = `web_entry`.`blog_id`) INNER JOIN `web_entry` T3 ON (`web_blog`.`id` = T3.`blog_id`) WHERE (`web_entry`.`head_line` LIKE BINARY %Lennon% AND T3.`pub_date` BETWEEN 2008-01-01 AND 2008-12-31)

```

包含与键查找：

> `contains`：`JSONField` 上的 `contains` 查找已被覆盖，返回的对象是那些给定的键值对都包含在顶级字段中的对象；
>
> `contained_by`：这是 `contains` 查找逆过程——返回的对象将是那些传递的值中的子集在对象上的键值对；
>
> `has_key`：返回给定的键位于数据顶层的对象；
>
> `has_keys`：返回所有给定的键位于数据顶层的对象；
>
> `has_any_keys`：返回任何给定的键位于数据顶层的对象。

 `delete()`：该方法立刻删除对象，并返回被删除的对象数量和一个包含了每个被删除对象类型的数量的字典。

## 聚合

- 速查表

```bash
In [3]: ShopBook.objects.filter(publisher__name='BalonyPress').count()
Out[3]: 0

In [8]: ShopBook.objects.all().aggregate(Avg('price'))
Out[8]: {'price__avg': Decimal('57.750000')}

In [10]: ShopBook.objects.all().aggregate(Max('price'))
Out[10]: {'price__max': Decimal('59.00')}

In [13]: ShopBook.objects.aggregate(price_diff=Max('price', output_field=DecimalField()) - Avg('price'))
Out[13]: {'price_diff': Decimal('1.250000')}

In [15]: pubs = ShopPublisher.objects.annotate(num_books=Count('shopbook'))

In [17]: pubs[0].num_books
Out[17]: 2

In [18]: above_5 = Count('shopbook', filter=Q(shopbook__rating__gt=5))

In [19]: below_5 = Count('shopbook', filter=Q(shopbook__rating__lte=5))

In [20]: pubs = ShopPublisher.objects.annotate(above_5=above_5).annotate(below_5=below_5)

In [21]: pubs[0].above_5
Out[21]: 0

In [22]: pubs[0].below_5
Out[22]: 2

In [23]: pubs = ShopPublisher.objects.annotate(num_books=Count('shopbook')).order_by('-num_books')[:2]

In [24]: pubs[0].num_books
Out[24]: 2
```

- 在 `QuerySet` 上生成聚合

`Django` 提供了两种生成聚合的方法：

> 1）是从整个 `QuerySet` 生成汇总值；
>
> 2）为 `QuerySet` 的每一个对象生成独立汇总。

- 连接(`Joins`)和聚合

```bash
In [35]: qs = ShopStore.objects.annotate(min_price=Min('books__price'), max_price=Max('books__price'))

In [36]: print(qs.query)
SELECT `shop_store`.`id`, `shop_store`.`name`, MIN(`shop_book`.`price`) AS `min_price`, MAX(`shop_book`.`price`) AS `max_price` FROM `shop_store` LEFT OUTER JOIN `shop_store_books` ON (`shop_store`.`id` = `shop_store_books`.`shopstore_id`) LEFT OUTER JOIN `shop_book` ON (`shop_store_books`.`shopbook_id` = `shop_book`.`id`) GROUP BY `shop_store`.`id` ORDER BY NULL

In [40]: qs = ShopStore.objects.aggregate(min_price=Min('books__price'), max_price=Max('books__price'))

In [41]: qs
Out[41]: {'min_price': Decimal('56.50'), 'max_price': Decimal('59.00')}

In [45]: qs = ShopStore.objects.aggregate(youngest_age=Min('books__authors__age'))

In [46]: qs
Out[46]: {'youngest_age': 30}
```

当一个 `annotate()` 子句应用于查询，会根据查询状态来计算注解，直到请求的注解为止。这实际上意味着 `filter()` 和 `annotate()` 不是可交换的操作。

如果 `values()` 子句在 `annotate()` 子句之前，任何注解将自动添加在结果集中。然而，如果 `values()` 子句应用在 `annotate()` 子句之后，则需要显式包含聚合列。

当使用 `aggregate()`子句时，提供的定义可以引用任何定义在查询中`annotate()`子句的别名。

## 搜索

- 与 `PostgreSQL` 特性相关的知识
- 全文搜索

> `django.contrib.postgres.search` 模块中的数据库函数方便了 `PostgreSQL` 的 全文搜索引擎的使用。
>
> > https://docs.djangoproject.com/zh-hans/3.2/ref/contrib/postgres/search/

> `search` 查找：使用全文检索的常见方法是针对数据库中的单一列进行单项检索；
>
> `SearchVector(*expressions, config=None, weight=None)`：对单个字段进行搜索是很好的，但有很大的局限性；
>
> `SearchQuery(value, config=None, search_type='plain')`：`SearchQuery` 将用户提供的术语转化为搜索查询对象，数据库将其与搜索向量进行比较。默认情况下，用户提供的所有词语都会通过词干算法，然后寻找所有结果词语的匹配；
>
> > 如果 `search_type` 是 `'plain'`，即默认值，则将术语作为单独的关键字处理；
> >
> > 如果 `search_type` 是 `'phrase'`，则将术语作为一个单一的短语处理；
> >
> > 如果 `search_type` 是 `'raw'`，那么可以提供一个带有术语和运算符的格式化搜索查询；
> >
> > 如果 `search_type` 是 `'websearch'`，那么可以提供一个格式化的搜索查询，类似于网络搜索引擎使用的格式。
> >
> > > `'websearch'` 需要 `PostgreSQL ≥ 11`。
>
> `SearchRank(vector, query, weights=None, normalization=None, cover_density=False)`：`PostgreSQL` 提供了一个排序函数，它考虑了查询术语在文档中出现的频率，术语在文档中的相近程度，以及它们出现的部分在文档中的重要性，匹配度越高，排名值越高；
>
> `SearchHeadline(expression, query, config=None, start_sel=None, stop_sel=None, max_words=None, min_words=None, short_word=None, highlight_all=None, max_fragments=None, fragment_delimiter=None)`：接受一个文本字段或一个表达式、一个查询、一个配置和一组选项，返回高亮显示的搜索结果；
>
> `TrigramSimilarity(expression, string, **extra)`：接受一个字段名或表达式，以及一个字符串或表达式，返回两个参数之间的三元相似度；
>
> `TrigramDistance(expression, string, **extra)`：接受一个字段名或表达式，以及一个字符串或表达式，返回两个参数之间的三元距离。

## 管理器

`Manager` 是一种接口，它赋予了 `Django` 模型操作数据库的能力。`Django` 应用中每个模型拥有至少一个 `Manager`。

继承基类 `Manager`，在模型中实例化自定义 `Manager`，你就可以在该模型中使用自定义的 `Manager`：

> 1）添加额外的 `Manager` 方法；
>
> 2）修改 `Manager` 返回的原始 `QuerySet`。

在一个模型中使用多个管理器，你可以为一个模型添加任意多个 `Manager()`。

`Model._default_manager`：默认管理器，若使用自定义 `Manager` 对象，注意 `Django` 遇到的第一个 `Manager` （按照在模型中定义的顺序）会拥有一个独特的状态。`Django` 将类定义中的第一个 `Manager` 视作 “默认” `Manager`，`Django` 的几个组件（包括 `dumpdata`）在用到该模型时会独立地调用该 `Manager`。

`Model._base_manager`：基础管理器，用于访问关联对象的管理器，默认情况下，`Django` 访问关联对象（即 `choice.question`）时使用 `Model._base_manager` 管理器类的实例，而不是关联对象的 `_default_manager`。

你可以通过 [`Meta.default_manager_name`](https://docs.djangoproject.com/zh-hans/3.2/ref/models/options/#django.db.models.Options.default_manager_name) 指定一个自定义的默认管理器。

## 执行原生 `SQL` 查询

> 1）使用 `Manager.raw()` 来执行原生查询并返回模型实例；
>
> 2）直接执行自定义 `SQL`。

`Manager.raw(raw_query, params=(), translations=None)`：该方法接受一个原生 `SQL` 查询语句，执行它，并返回一个 `django.db.models.query.RawQuerySet` 实例。这个 `RawQuerySet` 能像普通的 `QuerySet` 一样被迭代获取对象实例。

```bash
# Raw query must include the primary key
In [13]: blog = Blog.objects.raw('select id,name from web_blog;')

In [14]: blog
Out[14]: <RawQuerySet: select id,name from web_blog;>

In [15]: print(blog[0])
Beatles Blog

```





## 数据库事务

## 多数据库

## 表空间

## 数据库访问优化

## 数据库工具

## 模型关联 `API` 示例

## `QuerySet API` 参考

`QuerySet` 本身可以被构造，过滤，切片，或者复制赋值等，是无需访问数据库的。只有在需要从数据库取出数据或者，向数据库存入数据时才需要访问数据库。

> **迭代**： 一个 `QuerySet` 是可迭代的，当第一次迭代它时，它就会执行其数据库查询；
>
> **切片**：`QuerySet` 可以使用 `Python` 的数组切片语法进行切片，切片一个未执行的 `QuerySet` 通常会返回另一个未执行的 `QuerySet`，但如果使用切片语法的 `step` 参数，`Django` 会执行数据库查询，并返回一个列表；切片一个已经执行过的 `QuerySet` 也会返回一个列表；
>
> **`Pickle` 序列化／缓存**：结果是从数据库中读取的。
>
> **`repr()`**：当调用 `repr()` 时，所在 `QuerySet` 会被执行；
>
> **`len()`**：当你调用 `len()` 时，会执行 `QuerySet`，将返回结果列表的长度；
>
> **`list()`**：通过调用 `list()` 强制执行 `QuerySet`；
>
> **`bool()`**：在布尔语境中测试 `QuerySet`，如使用 `bool()`、`or`、`and` 或 `if` 语句，将导致查询被执行。如果至少有一个结果，则 `QuerySet` 为 `True`，否则为 `False`。
>
> > 如果只是确定至少一个结果是否存在，使用 `exists()` 会更有效；
> >
> > 如果只是确定至少一个结果是否存在（而不需要实际的对象），使用 `exences()` 更高效。

 ```bash
In [86]: import pickle

In [87]: qs = Blog.objects.values_list('id', 'name')

In [88]: qs
Out[88]: <QuerySet [(1, 'Beatles Blog'), (2, "English's BBC"), (3, 'Cheddar Talk')]>

In [89]: reload_qs = Blog.objects.all()

In [90]: reload_qs.query
Out[90]: <django.db.models.sql.query.Query at 0x10eb4ad30>

In [91]: reload_qs.query = pickle.loads(pickle.dumps(qs.query))

In [92]: reload_qs
Out[92]: <QuerySet [{'id': 1, 'name': 'Beatles Blog'}, {'id': 2, 'name': "English's BBC"}, {'id': 3, 'name': 'Cheddar Talk'}]>
 ```

`QuerySet` 类具有两个可用于自省的公开属性：

> `ordered`：`True` 如果 `QuerySet` 是有序的——即有一个 `order_by()` 子句或模型上的默认排序；否则为 `False`；
>
> `db`：如果现在执行这个查询，将使用的数据库。

- 返回新 `QuerySet` 的方法

> `filter(**kwargs)`：包含与给定查找参数相匹配的对象；
>
> `exclude(**kwargs)`：包含与给定查找参数不匹配的对象；
>
> `annotate(*args, **kwargs)`：用所提供的查询表达式列表对 `QuerySet` 中的每个对象进行注解。表达式可以是一个简单的值，也可以是对模型（或任何相关模型）字段的引用，或者是对与 `QuerySet` 中的对象相关的对象进行计算的聚合表达式（平均数、总和等）；`annotate()` 的每个参数都是一个注解，将被添加到返回的 `QuerySet` 中的每个对象；
>
> `alias(*args, **kwargs)`：`Django 3.2` 中的新功能；与 `annotate()` 相同，但不是在 `QuerySet` 中注释对象，而是 `QuerySet`保存表达式以供以后与其他`QuerySet` 方法重用。当不需要表达式本身的结果但它用于过滤、排序或作为复杂表达式的一部分时，这很有用；
>
> `order_by(*fields)`：默认情况下，`QuerySet` 返回的结果是按照模型 `Meta` 中的 `ordering` 选项给出的排序元组排序的；
>
> > `"-pub_date"` 前面的负号表示降序；
> >
> > 升序是隐含的；
> >
> > 要随机排序，使用 `"?"`。
>
> `reverse()`：使用 `reverse()` 方法来反向返回查询集元素的顺序；第二次调用 `reverse()` 会将顺序恢复到正常方向；
>
> `distinct(*fields)`：在其 `SQL` 查询中使用 `SELECT DISTINCT`，这将消除查询结果中的重复记录；
>
> `values(*fields, **expressions)`：当用作可迭代对象时，返回字典，而不是模型实例；
>
> `values_list(*fields, flat=False, named=False)`：与 `values()` 类似，只是在迭代时不返回字典，而是返回元组；
>
> > 如果只传入一个字段，也可以传入 `flat` 参数。如果 `True`，这将意味着返回的结果是单个值，而不是一个元组；
> >
> > 当有多个字段时，通过 `named=True` 来获取结果为 `namedtuple()`。
>
> `dates(field, kind, order='ASC')`：其值是一个 `datetime.date` 对象的列表，代表 `QuerySet` 内容中所有可用的特定日期；
>
> > `field` 是模型的 `DateField` 的名称；
> >
> > `kind` 应该是``"year"`、`"month"`、`"week"`` 或 `"day"`，结果列表中的每个 `datetime.date` 对象都被“截断”为给定的 ` type`；
> >
> > `order` 默认为 `'ASC'`，应该是 `'ASC'` 或 `’DESC'`。
>
> `datetimes(field_name, kind, order='ASC', tzinfo=None, is_dst=None)`：其值是一个 `datetime.datetime` 对象的列表，代表 `QuerySet` 内容中所有可用的特定日期；
>
> > `field_name` 是模型中 `DateTimeField` 的名称；
> >
> > `kind` 应该是 `"year"`、`"month"`、`"week"`、`"day"`、`"hour"`、`"minute"` 或 `"second"`，结果列表中的每个 `datetime.datetime` 对象都被“截断”为给定的 `type`；
> >
> > `order`，默认为 `'ASC'`，应该是 `'ASC'` 或 `'DESC'`；
> >
> > `tzinfo` 定义了在截断之前将日期时间转换为的时区，这个参数必须是一个 `datetime.tzinfo` 对象；如果是 `None`，Django 会使用 `current time zone`，当 `USE_TZ` 为 `False` 时，它没有效果；
> >
> > `is_dst` 是 `Django3.1` 新增的参数，表示 `pytz` 是否应该解释夏令时中不存在的和含糊不清的日期，默认情况下（当 `is_dst=None`），`pytz` 会对这种日期时间产生异常。
>
> `none()`：调用`none()`将创建一个永远不会返回任何对象的查询集，并且在访问结果时不会执行任何查询，查询集`qs.none()`是 的一个实例`EmptyQuerySet`；
>
> `all()`：返回当前 `QuerySet` （或 `QuerySet` 子类）的副本；
>
> `union(*other_qs , all=False)`：使用 `SQL` 的 `UNION` 操作符来组合两个或多个 `QuerySet` 的结果；
>
> `intersection(*other_qs)`：使用 `SQL` 的 `INTERSECT` 操作符来返回两个或多个 `QuerySet` 的共享元素；
>
> `difference(*other_qs)`：使用 `SQL` 的 `EXCEPT` 操作符，只保留存在于 `QuerySet` 中的元素，而不保留在其他 `QuerySet` 中的元素；
>
> `select_related(*fields)`：将“跟随”外键关系，在执行查询时选择额外的相关对象数据。这是一个性能提升器，它导致一个更复杂的单一查询，但意味着以后使用外键关系将不需要数据库查询；
>
> `prefetch_related(*query)`：为了阻止因访问相关对象而引起的数据库查询潮，将在一个批次中自动检索每个指定查询的相关对象；`prefetch_related()` 中的附加查询是在 `QuerySet` 开始执行和主要查询被执行后执行的；查询创建的对象可以在与其相关的不同对象之间共享，即一个 `Python` 模型实例可以出现在返回的对象树的多个点上；
>
> `extra(select=None , where=None , params=None , tables=None , order_by=None , select_params=None )`：用于将特定的子句注入到由 `QuerySet` 生成的 `SQL` 中；**在万不得已的情况下使用这种方法**；
>
> `defer(*fields)`：通过将不加载的字段名称传递给 `defer()`；
>
> `only(*fields)`：在检索模型时，调用它的时候，应该调用那些不应该递延的字段； 
>
> `using(alias)`：如果使用多个数据库，该方法用于控制 `QuerySet` 将针对哪个数据库进行评估。 本方法的唯一参数是数据库的别名，定义在 `DATABASES` 中；
>
> `select_for_update(nowait=False, skip_locked=False, of=(), no_key=False)`：返回一个查询集，该查询集将锁定行直到事务结束，从而在受支持的数据库上生成 `SELECT ... FOR UPDATE` `SQL` 语句；
>
> `raw(raw_query, params=(), translations=None)`：获取一个原始 `SQL` 查询，执行它，并返回一个 `django.db.models.query.RawQuerySet` 实例。

- 返回新 `QuerySet` 的操作符

> `AND（&）`：使用 `SQL` `AND` 操作符将两个 `QuerySet` 组合起来；
>
> `OR（|）`：使用 `SQL` `OR` 操作符将两个 `QuerySet` 组合起来。

- 不返回 `QuerySet` 的方法

> `get(**kwargs)`：返回与给定的查找参数相匹配的对象；
>
> `create(**kwargs)`：用于创建一个对象并一步到位地保存；
>
> `get_or_create(defaults=None, **kwargs)`：用于查找具有给定 `kwargs` 的对象（如果你的模型对所有字段都有默认值，则可能为空），必要时创建一个对象；
>
> `update_or_create(defaults=None, **kwargs)`：用给定的 `kwargs` 更新对象的一种方便方法，是必要时创建一个新对象，`defaults` 是用来更新对象的 `(field, value)` 对的字典，`defaults` 中的值可以是可调用对象；
>
> `bulk_create(objs, batch_size=None, ignore_conflicts=False)`：以高效的方式将提供的对象列表插入数据库（通常只有 1 个查询，无论有多少个对象），并按照提供的顺序将创建的对象作为列表返回；
>
> > 模型的 `save()` 方法将不会被调用，`pre_save` 和 `post_save` 信号将不会被发送；
> >
> > 在多表继承的情况下，它不能与子模型一起工作；
> >
> > 如果模型的主键是一个 `AutoField`，那么主键属性只能在某些数据库（目前是 `PostgreSQL` 和 `MariaDB 10.5+`）上被检索到，在其他数据库上，它将不会被设置；
> >
> > 对于多对多的关系，它是行不通的；
> >
> > 它将 `objs` 转换为一个列表，如果 `objs` 是一个生成器，则完全执行 `objs`。
>
> `bulk_update(objs , fields , batch_size=None)`：可以有效地更新所提供的模型实例上的给定字段，一般只需查询一次；
>
> > 不能更新模型的主键；
> >
> > 每个模型的 `save()` 方法没有被调用，而且 `pre_save` 和 `post_save` 信号没有被发送；
> >
> > 如果更新大量行中的大量列，生成的 `SQL` 可能非常大；通过指定一个合适的 `batch_size` 来避免这种情况；
> >
> > 更新定义在多表继承祖先上的字段将给每个祖先带来额外的查询；
> >
> > 当单个批次包含重复项时，只有该批次中的第一个实例会导致更新。
>
> `count()`：返回一个整数，表示数据库中与 `QuerySet` 匹配的对象数量；
>
> `in_bulk(id_list=None , * , field_name='pk')`：获取字段值 ( `id_list`) 和`field_name`这些值的列表，并返回一个字典，将每个值映射到具有给定字段值的对象实例；
>
> `iterator(chunk_size=2000)`：执行 `QuerySet` （通过执行查询），并在结果上返回一个迭代器；
>
> > 使用服务器端游标
> >
> > > `Oracle` 和 `PostgreSQL` 使用服务器端的游标从数据库流式传输结果，而不需要将整个结果集加载到内存中；
> > >
> > > `Oracle` 数据库驱动程序总是使用服务器端的游标。
> >
> > 没有服务器端游标
> >
> > > `MySQL` 不支持流式结果，因此 `Python` 数据库驱动将整个结果集加载到内存中。
>
> `latest(*fields)`：根据给定的字段，返回表中最新的对象；
>
> `earliest(*fields)`：除了方向改变外，其他工作方式都像 `last()`；
>
> > `earliest()` 和 `latest()` 可能返回日期为空的实例。
>
> `first()`：返回查询集匹配的第一个对象，如果没有匹配的对象，则返回 `None`；
>
> `last()`：与 `first()` 工作原理相同，但返回的是查询集中的最后一个对象；
>
> `aggregate(*args , **kwargs)`：返回对 `QuerySet` 计算的聚合值（平均值、总和等）的字典。`aggregate()` 的每个参数都指定了一个将被包含在返回的字典中的值；
>
> `exists()`：如果 `QuerySet` 包含任何结果，则返回 `True`，如果不包含，则返回 `False`；
>
> `update(**kwargs)`：对指定的字段执行 `SQL` 更新查询，并返回匹配的行数（如果有些行已经有了新的值，则可能不等于更新的行数）；
>
> `Ordered queryset`：`Django 3.2` 中的新功能，链接`order_by()`与`update()`只在 `MariaDB` 的和 `MySQL` 支持，并且忽略不同的数据库；
>
> `delete()`：对 `QuerySet` 中的所有行执行 `SQL` 删除查询，并返回删除的对象数量和每个对象类型的删除数量的字典；
>
> `as_manager()`：类方法，该方法返回一个 `Manager` 的实例，其中包含 `QuerySet` 的方法的副本；
>
> `explain(format=None, **options)`：返回一个 `QuerySet` 的执行计划的字符串，它详细说明了数据库将如何执行查询，包括将使用的任何索引或联接。

- `Field` 查找

> `exact`：完全匹配，如果提供的比较值是 `None`，它将被解释为 SQL `NULL`；
>
> `iexact`：不区分大小写的完全匹配，如果提供的比较值是 `None`，它将被解释为 SQL `NULL`；
>
> `contains`：区分大小写的包含测试；
>
> `icontains`：不区分大小写的包含测试；
>
> `in`：在一个给定的可迭代对象中；通常是一个列表、元组或查询集。这不是一个常见的用例，但字符串（可迭代）是可以接受的；
>
> `gt`：大于；
>
> `gte`：大于等于；
>
> `lt`：小于；
>
> `lte`：小于等于；
>
> `startswith`：区分大小写的开头为；
>
> `istartswith`：不区分大小写的开头为；
>
> `endswith`：区分大小写的结尾为；
>
> `iendswith`：不区分大小写的结尾为；
>
> `range`：范围测试（含）；
>
> `date`：对于日期时间字段，将值投射为日期。允许链接其他字段的查找。取一个日期值；
>
> `year`：对于日期和日期时间字段，精确匹配年份。允许链接其他字段的查询。取整数年；
>
> `iso_year`：对于日期和日期时间字段，精确的 `ISO-8601` 周号年份匹配。允许链接其他字段的查询。取整数年；
>
> `month`：对于日期和日期时间字段，精确的月份匹配。允许链接其他字段的查询。取整数 1（1 月）到 12（12 月）；
>
> `day`：对于日期和日期时间字段，精确匹配日期。允许链接其他字段的查询。取整数日；
>
> `week`：对于日期和日期时间字段，根据 `ISO-8601` ，返回星期号（1-52 或 53），即星期从星期一开始，第一周包含一年的第一个星期四；
>
> `week_day`：对于日期和日期时间字段，“星期几”匹配。允许链接其他字段的查询，从 1（星期日）到 7（星期六）取一个整数值，代表一周的一天；
>
> `iso_week_day`：`Django 3.1` 中的新功能，对于日期和日期时间字段，精确匹配 `ISO 8601` 星期几。允许链接其他字段的查，取一个整数值，代表一周的 1（星期一）到 7（星期日）；
>
> `quarter`：对于日期和日期时间字段，“一年的四分之一”匹配。允许链接额外的字段查找。取 1 到 4 之间的整数值，代表一年中的季度；
>
> `time`：对于日期时间字段，将其值强制转换为时间。允许链式附加字段查找。取一个 `datetime.time` 的值；
>
> `hour`：对于日期时间和时间字段，精确的小时匹配。允许链式查找其他字段。取 0 到 23 之间的整数；
>
> `minute`：对于日期时间和时间字段，精确的分钟匹配。允许链式查找其他字段。取 0 到 59 之间的整数；
>
> `second`：对于日期时间和时间字段，完全秒配。允许链式查找其他字段。取 0 到 59 之间的整数；
>
> `isnull`：取 `True` 或 `False`，分别对应 `IS NULL` 和 `IS NOT NULL` 的 `SQL` 查询；
>
> `regex`：区分大小写的正则表达式匹配；
>
> `iregex`：不区分大小写的正则表达式匹配；

- 聚合函数

> `expressions`：引用模型上的字段、字段转换或查询表达式的字符串；
>
> `output_field`：一个可选的参数，表示返回值的模型字段；
>
> `filter`：一个可选的 `Q` 对象，用于过滤被聚合的行；
>
> `**extra`：关键字参数，可以为聚合生成的 `SQL` 提供额外的上下文；
>
> `Avg(expressions, output_field=None, distinct=False, filter=None, **extra)`：返回给定表达式的平均值，除非指定不同的 `output_field`，否则必须是数值；
>
> `Count(expressions, distinct=False, filter=None, **extra)`：返回通过提供的表达式关联的对象数量；
>
> `Max(expressions, output_field=None, filter=None, **extra)`：返回给定表达式的最大值；
>
> `Min(expressions, output_field=None, filter=None, **extra)`：返回给定表达式的最小值；
>
> `StdDev(expressions, output_field=None, sample=False, filter=None, **extra)`：返回给定表达式中数据的标准差；
>
> `Sum(expressions, output_field=None, distinct=False , filter=None , **extra)`：计算给定表达式的所有值的总和；
>
> `Variance(expressions, output_field=None, sample=False, filter=None, **extra)`：返回给定表达式中数据的方差。

- 查询相关工具

> `Q()` 对象：表示一个 `SQL` 条件，它可以用于数据库相关的操作；
>
> `Prefetch()` 对象：用来控制 `prefetch_related()` 的操作；
>
> `prefetch_related_objects()`：在作为模型实例的可迭代对象上预取给定的查找。这在接收模型实例列表而不是 `QuerySet` 的代码中很有用；传递一个作为模型实例的可迭代对象（必须都是同一个类）和你想预取的查找或 `Prefetch` 对象；
>
> `FilteredRelation()` 对象：与 `annotate()`b.  一起使用，在执行 `JOIN` 时创建一个 `ON` 子句。

```bash
In [100]: from django.db.models import Count

In [101]: qs = Blog.objects.annotate(Count('entry'))

In [102]: qs[0].name
Out[102]: 'Beatles Blog'

In [103]: qs[0].entry__count
Out[103]: 0

In [104]: print(qs.query)
SELECT `web_blog`.`id`, `web_blog`.`name`, `web_blog`.`tag_line`, COUNT(`web_entry`.`id`) AS `entry__count` FROM `web_blog` LEFT OUTER JOIN `web_entry` ON (`web_blog`.`id` = `web_entry`.`blog_id`) GROUP BY `web_blog`.`id` ORDER BY NULL

In [105]: qs = Blog.objects.annotate(number_of_entries=Count('entry'))

In [106]: qs[2].number_of_entries
Out[106]: 1

In [109]: blogs = Blog.objects.alias(entries=Count('entry')).filter(entries__gt=0)

In [113]: print(blogs.query)
SELECT `web_blog`.`id`, `web_blog`.`name`, `web_blog`.`tag_line` FROM `web_blog` LEFT OUTER JOIN `web_entry` ON (`web_blog`.`id` = `web_entry`.`blog_id`) GROUP BY `web_blog`.`id` HAVING COUNT(`web_entry`.`id`) > 0 ORDER BY NULL

In [122]: from django.db.models import F, Sum

In [123]: blogs = Blog.objects.alias(entries=Count('entry')).annotate(
     ...:    entries=F('entries'),
     ...:    ).aggregate(Sum('entries'))

In [124]: blogs
Out[124]: {'entries__sum': 1}

In [133]: from django.db.models.functions import Lower

In [134]: Blog.objects.values(lower_name=Lower('name'))
Out[134]: <QuerySet [{'lower_name': 'beatles blog'}, {'lower_name': "english's bbc"}, {'lower_name': 'cheddar talk'}]>

In [136]: Entry.objects.dates('pub_date', 'year')
Out[136]: <QuerySet [datetime.date(2021, 1, 1)]>

In [137]: Entry.objects.dates('pub_date', 'month')
Out[137]: <QuerySet [datetime.date(2021, 8, 1)]>

In [138]: Entry.objects.dates('pub_date', 'day')
Out[138]: <QuerySet [datetime.date(2021, 8, 28)]>

In [139]: Entry.objects.dates('pub_date', 'week')
Out[139]: <QuerySet [datetime.date(2021, 8, 23)]>

In [141]: from django.db.models.query import EmptyQuerySet

In [142]: isinstance(Entry.objects.none(), EmptyQuerySet)
Out[142]: True

In [143]: qs1 = Author.objects.values_list('name')

In [144]: qs2 = Entry.objects.values_list('head_line')

In [145]: qs1.union(qs2).order_by('name')
Out[145]: <QuerySet [('Joe',), ('John',), ('News of BBS',), ('Paul',), ('zhangbc',), ('zhangw',)]>

In [146]: q = qs1.union(qs2).order_by('name')

In [147]: print(q.query)
(SELECT `web_author`.`name` FROM `web_author`) UNION (SELECT `web_entry`.`head_line` FROM `web_entry`) ORDER BY (1) ASC

In [8]: e = Entry.objects.select_related('blog').get(id=1)

In [11]: blogs = Blog.objects.extra(
    ...:   select={
    ...:       'entry_count': 'select count(*) from web_entry where web_entry.blog_id=web_blog.id'
    ...:       },)

In [12]: print(blogs.query)
SELECT (select count(*) from web_entry where web_entry.blog_id=web_blog.id) AS `entry_count`, `web_blog`.`id`, `web_blog`.`name`, `web_blog`.`tag_line` FROM `web_blog`

In [13]: blogs
Out[13]: <QuerySet [<Blog: Beatles Blog>, <Blog: English's BBC>, <Blog: Cheddar Talk>]>

In [9]: obj,created = Person.objects.get_or_create(first_name='John',
   ...:                          last_name='Lennon',
   ...:                          age = 18,
   ...:                          shirt_size='M',
   ...:                          birth_date=date(1940,10,9))

In [11]: obj, created
Out[11]: (<Person: >, True)

In [11]: e = Entry.objects.filter(pub_date__week_day=2)

In [12]: print(e.query)
SELECT `web_entry`.`id`, `web_entry`.`blog_id`, `web_entry`.`head_line`, `web_entry`.`body_text`, `web_entry`.`pub_date`, `web_entry`.`mod_date`, `web_entry`.`number_of_comments`, `web_entry`.`number_of_pingbacks`, `web_entry`.`rating` FROM `web_entry` WHERE DAYOFWEEK(`web_entry`.`pub_date`) = 2

In [13]: e = Entry.objects.filter(pub_date__quarter=2)

In [14]: print(e.query)
SELECT `web_entry`.`id`, `web_entry`.`blog_id`, `web_entry`.`head_line`, `web_entry`.`body_text`, `web_entry`.`pub_date`, `web_entry`.`mod_date`, `web_entry`.`number_of_comments`, `web_entry`.`number_of_pingbacks`, `web_entry`.`rating` FROM `web_entry` WHERE EXTRACT(QUARTER FROM `web_entry`.`pub_date`) = 2


```

## 项目问题及解决方案

1，`uwsgi` 运行报错，具体信息如下：

```bash
(django3.2) (base) ☁  mysite [master] ⚡  uwsgi --help
dyld: Library not loaded: @rpath/libpcre.1.dylib
  Referenced from: /Users/zhangbocheng/.virtualenvs/django3.2/bin/uwsgi
  Reason: image not found
[1]    75254 abort      uwsgi --help
```

解决方案：用 `conda` 安装。 

## 参考资料

- [Pip 安装uwsgi报错，用conda吧](https://blog.csdn.net/BIKEONEPIECE/article/details/105882799)

